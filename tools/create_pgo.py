#!/usr/bin/env python3
"""
Profile-Guided Optimization (PGO) Profile Generator
===================================================

This script automates the creation of CPU profiles for Go's Profile-Guided Optimization (PGO).
PGO allows the Go compiler to optimize the application based on runtime behavior, potentially
improving performance by 2-14% (depending on the workload).

The script performs the following steps:
1.  **Cleanup**: Removes any existing profile files to ensure a clean state.
2.  **Benchmark**: Runs Go benchmarks for specified critical packages.
    -   It uses `-cpuprofile` to capture execution data.
    -   It disables existing PGO (`-pgo=off`) to establish a baseline.
    -   It runs for 10 seconds (`-benchtime=10s`) to gather sufficient samples.
3.  **Merge**: Combines individual package profiles into a single `cpuprofile.pprof` file.
    -   The Go compiler expects a single profile file for PGO.
4.  **Visualize**: Generates an SVG graph (`cpuprofile.svg`) for human analysis.
5.  **Cleanup**: Removes intermediate files, leaving only the final artifacts.

Usage:
    python3 tools/create_pgo.py

Expected working directory:
    Run this from the repository root. The script writes artifacts into the
    current working directory.

Prerequisites:
    - Go toolchain on PATH (this script runs `go test` and `go tool pprof`).
    - Graphviz installed if you want the SVG output (`go tool pprof -svg` calls `dot`).

Side effects:
    - Deletes matching files in the working directory:
      - cpuprofile*.pprof
      - *.test
    - Overwrites `cpuprofile.pprof` and `cpuprofile.svg`.

Artifacts:
    - cpuprofile.pprof: The merged profile used by `go build -pgo`.
    - cpuprofile.svg:   A visualization of the profile for performance analysis.

Template note:
    Profiling artifacts are typically generated locally and ignored by git in this
    template. If you want stable, reproducible image builds across machines, you can
    commit `cpuprofile.pprof` and remove the ignore rule for it.
"""

import glob
import os
import subprocess
import sys

# List of packages to profile.
# These should be the core domains and adapters where performance matters most.
PACKAGES_TO_PROFILE = [
    "cmd/server",
    "internal/adapters/inbound",
    "internal/adapters/outbound",
]


def run_command(command, shell=False, check=True):
    """
    Runs a shell command and handles errors gracefully.

    Args:
        command (list or str): The command to run.
        shell (bool): Whether to run the command in a shell.
        check (bool): Whether to raise an exception on non-zero exit codes.
    """
    try:
        subprocess.run(command, shell=shell, check=check)
    except subprocess.CalledProcessError as e:
        print(f"Error running command: {command}")
        sys.exit(e.returncode)


def main():
    print("Starting PGO profile generation...")

    # -------------------------------------------------------------------------
    # 1. Cleanup existing profiles
    # -------------------------------------------------------------------------
    print("Cleaning up old profiles...")
    # These files are generated artifacts. We remove them first to avoid
    # accidentally merging stale data.
    # Remove any previous pprof files to avoid merging old data
    for f in glob.glob("cpuprofile*.pprof"):
        os.remove(f)
    # Remove test binaries generated by 'go test'
    for f in glob.glob("*.test"):
        os.remove(f)

    # -------------------------------------------------------------------------
    # 2. Run benchmarks for each package
    # -------------------------------------------------------------------------
    # The profile quality depends on representative workloads.
    # We use benchmarks as the workload driver because they are deterministic and
    # live close to the code under test.
    for pkg in PACKAGES_TO_PROFILE:
        print(f"Profiling package: {pkg}")

        # Create a safe filename suffix (replace / with __) to avoid path issues
        suffix = pkg.replace("/", "__").replace("\\", "__")
        output_file = f"cpuprofile-{suffix}.pprof"

        # Construct the go test command for benchmarking
        # -run=^$      : Don't run any unit tests (only benchmarks)
        # -bench=.     : Run all benchmarks in the package
        # -benchtime=10s : Run for 10 seconds to ensure statistically significant data
        # -cpuprofile  : Output the CPU profile to a specific file
        # -pgo=off     : IMPORTANT: Disable PGO during profiling to get a clean baseline.
        #                Profiling an already optimized binary can skew results.
        cmd = [
            "go",
            "test",
            f"./{pkg}/...",
            "-run=^$",
            "-bench=.",
            "-benchtime=10s",
            f"-cpuprofile={output_file}",
            "-pgo=off",
        ]

        # Run the benchmark, suppressing stdout/stderr to keep the output clean.
        # We only care if it fails.
        try:
            subprocess.run(
                cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
            )
        except subprocess.CalledProcessError:
            print(f"Failed to profile package: {pkg}")
            sys.exit(1)

    # -------------------------------------------------------------------------
    # 3. Merge profiles
    # -------------------------------------------------------------------------
    print("Merging profiles...")
    # The Go compiler needs a single profile file. We use 'go tool pprof' to merge
    # the individual package profiles into one.
    # We use shell=True here to leverage globbing (cpuprofile-*.pprof) in the command.
    merge_cmd = "go tool pprof -proto cpuprofile-*.pprof > cpuprofile-merged.pprof"
    run_command(merge_cmd, shell=True)

    # -------------------------------------------------------------------------
    # 4. Finalize profile file
    # -------------------------------------------------------------------------
    print("Finalizing cpuprofile.pprof...")
    # Rename/Copy the merged file to the standard name 'cpuprofile.pprof'
    # This is the file that should be committed to the repo for PGO.
    try:
        with (
            open("cpuprofile-merged.pprof", "rb") as src,
            open("cpuprofile.pprof", "wb") as dst,
        ):
            dst.write(src.read())
    except IOError as e:
        print(f"Error copying merged profile: {e}")
        sys.exit(1)

    # -------------------------------------------------------------------------
    # 5. Generate visualization
    # -------------------------------------------------------------------------
    print("Generating SVG visualization...")
    # Create an SVG graph of the profile. This is useful for developers to see
    # where the application is spending its time (hot paths).
    svg_cmd = "go tool pprof -svg cpuprofile.pprof > cpuprofile.svg"
    run_command(svg_cmd, shell=True)

    # -------------------------------------------------------------------------
    # 6. Cleanup intermediate files
    # -------------------------------------------------------------------------
    print("Cleaning up intermediate files...")
    # Remove the individual package profiles and the temporary merged file
    for f in glob.glob("cpuprofile-*.pprof"):
        os.remove(f)
    for f in glob.glob("*.test"):
        os.remove(f)

    if os.path.exists("cpuprofile-merged.pprof"):
        os.remove("cpuprofile-merged.pprof")

    print("PGO generation complete!")
    print("  - Created 'cpuprofile.pprof' (Commit this file)")
    print("  - Created 'cpuprofile.svg'   (View this to analyze performance)")


if __name__ == "__main__":
    main()
